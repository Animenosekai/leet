import pathlib
import shutil
import subprocess
import sys
import typing

import warnings
from leet import runner

CHECK_VERSION = (
    "import sys; print(sys.version_info.major); print(sys.version_info.minor)"
)


def check_python_version(executable: str) -> typing.Tuple[int, int]:
    """
    Parameters
    ----------
    executable: str

    Returns
    -------
    tuple
    """
    lines = subprocess.check_output([executable, "-c", CHECK_VERSION]).splitlines()
    return (int(lines[0]), int(lines[1]))


class Python3Runner(runner.Runner):
    HEADER = r'''"""
This file is automatically generated and emulates the Python environment on the LeetCode platform.
"""

# Wildcard imports
from string import *
from re import *
from operator import *
from builtins import *
from typing import *
from datetime import *
from collections import *
from heapq import *
from bisect import *
from copy import *
from math import *
from random import *
from statistics import *
from itertools import *
from functools import *
from io import *
from sys import *
from json import *

# Module imports
import datetime
import bisect
import copy
import random
import string
import re
import collections
import heapq
import math
import statistics
import itertools
import functools
import operator
import io
import sys
import json
import os

# Disclaimer: The following modules are not available in this environment.
# `_driver`: This is an internal module which shouldn't be used in any problem.

# ------------------ `precompiled` ------------------
# The `precompiled` module is a module containing LeetCode custom datastructures.
# This is available at runtime on the LeetCode platform.
# It contains the following datastructures:
# - ListNode
# - NestedInteger
# - TreeNode

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class NestedInteger:
    def __init__(self, value=None):
        self.value = value

    def isInteger(self) -> bool:
        return isinstance(self.value, int)

    def getInteger(self) -> int:
        return self.value

    def getList(self) -> List['NestedInteger']:
        return self.value

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Creating a module to store the custom datastructures
import types
precompiled = types.ModuleType('precompiled', 'A module containing LeetCode custom datastructures.')
# Updating the module with the custom datastructures
precompiled.__dict__.update({
    'ListNode': ListNode,
    'NestedInteger': NestedInteger,
    'TreeNode': TreeNode,
})
# Adding it to the list of modules
sys.modules['precompiled'] = precompiled
# The `types` module is not in the default LeetCode Python environment.
del types

# Redefining the different datastructures for them to have the same behavior as module elements
ListNode = precompiled.ListNode
NestedInteger = precompiled.NestedInteger
TreeNode = precompiled.TreeNode
'''

    FOOTER = r'''# We could expect that the user decided to remove these imports for whatever reason
from typing import List, Tuple, Dict, Any
# Defining the tests
__LEETCODE_{run_id}_TESTS__: List[Tuple[Dict[str, Any], Any]] = {tests}
#                                       ^^^^^^^^^^^^^^  ^^^
#                                      Input arguments  Expected
#                                                       output
# Example: __LEETCODE_0_TESTS__ = [({{'val1': 1, 'val2': 2}}, 3)]

# We go a little bit fancy here
try:
    raise ImportError("This is a test import error")
    from rich.console import Console
    from rich.table import Table
    from rich.progress import Progress
except Exception:
    # But it shouldn't impact the run
    import traceback
    class Table:
        def __init__(self, title: str, *args, **kwargs):
            self.title = str(title)
            self.columns = []
            self.rows = []

        def add_column(self, title: str, *args, **kwargs):
            self.columns.append(str(title))

        def add_row(self, *args, **kwargs):
            self.rows.append([str(arg) for arg in args])

    class Console:
        def render(self, value: str) -> str:
            return str(value).replace("[red]", "\033[0;31m").replace("[/red]", "\033[0m").replace("[green]", "\033[0;32m").replace("[/green]", "\033[0m")

        def render_table(self, table: Table) -> List[str]:
            max_per_column = [max(len(row[index]) for row in [table.columns, *table.rows]) for index, _ in enumerate(table.columns)]
            return [
                self.render(table.title).center(sum(max_per_column) + len(table.columns) * 3),
                "",
                " â”‚ ".join(
                    column.center(max_per_column[index]) for index, column in enumerate(table.columns)
                ),
                "â”€â”¼â”€".join("â”€" * max_per_column[index] for index, _ in enumerate(table.columns)),
                " â”‚ ".join(
                    " â”‚ ".join(row[index].center(max_per_column[index]) for index, _ in enumerate(table.columns))
                    for row in table.rows
                ),
                ""
            ]
            
        def print(self, *args, **kwargs):
            if isinstance(args[0], Table):
                table = args[0]
                print("\n".join(self.render_table(table)))
            else:
                print(*[self.render(arg) for arg in args], **kwargs)

        def print_traceback(self, *args, **kwargs):
            self.print("[red]AN ERROR OCCURED[/red]", *args, **kwargs)
            traceback.print_exc()

        
    class Progress:
        def __init__(self, console: Console, total: int = -1, *args, **kwargs):
            self.console = console
            self.total = total

        def __enter__(self):
            return self

        def __exit__(self, exc_type, exc_val, exc_tb):
            pass

        def add_task(self, title: str, *args, **kwargs):
            return 0

        def advance(self, task: int, *args, **kwargs):
            pass

console = Console()

def __LEETCODE_{run_id}_RUN_TESTS__():
    """Runs the tests for the solution."""
    try:
        NUMBER_OF_TESTS = str(len(__LEETCODE_{run_id}_TESTS__))
        TEST_MESSAGE_TEMPLATE = f"Test {{{{index}}}}/{{NUMBER_OF_TESTS}}... "
        INDEX_JUSTIFICATION = len(NUMBER_OF_TESTS)
        MAX_MESSAGE_LENGTH = len(TEST_MESSAGE_TEMPLATE.format(index=NUMBER_OF_TESTS))
        with Progress(console=console, transient=True) as progress:
            task = progress.add_task("Running tests...", total=len(__LEETCODE_{run_id}_TESTS__))
            progress.add_task(task)

            for index, (test, expected) in enumerate(__LEETCODE_{run_id}_TESTS__, start=1):
                testing_message = TEST_MESSAGE_TEMPLATE.format(index=str(index).ljust(INDEX_JUSTIFICATION))
                print(testing_message, end="\r")
                # Here, we make sure that the `Solution` class is re-instantiated for each test
                sol = {function_name}(
                    **test
                )
                if sol != expected:
                    console.print(testing_message + "[red]FAILED[/red] â›‘ï¸".rjust(MAX_MESSAGE_LENGTH - len(testing_message)))
                    table = Table(title=f"Test {{index}}/{{NUMBER_OF_TESTS}} â€” [red]Failure[/red]")
                    table.add_column("Input")
                    table.add_column("Output")
                    table.add_column("Expected")
                    table.add_row(str(test), str(sol), str(expected))
                    console.print(table)
                    exit(1)
                else:
                    console.print(testing_message + "PASSED âœ…".rjust(MAX_MESSAGE_LENGTH - len(testing_message)))
                
                progress.advance(task)
    except Exception as exc:
        console.print_traceback()
        raise exc
    
    print("âœ¨ All tests passed! ðŸ™†")

if __name__ == "__main__":
    # Running the solution
    __LEETCODE_{run_id}_RUN_TESTS__()
'''
    "This takes `run_id`, `tests` and `function_name` as arguments"

    @classmethod
    def encode_tests(cls, tests: typing.List[runner.Test]) -> str:
        """
        Parameters
        ----------
        cls
        tests: list

        Returns
        -------
        str
        """
        return repr([
            (test.arguments, test.expected) for test in tests
        ]).strip("'")

    @classmethod
    def get_executable(cls) -> str:
        major, minor = (sys.version_info.major, sys.version_info.minor)
        if major != 3 or minor != 11:
            python_exec = shutil.which("python3.11")
            major, minor = check_python_version(python_exec)
            if major != 3 or minor != 11:
                python_exec = shutil.which("python3")
                major, minor = check_python_version(python_exec)
            if major != 3 or minor != 11:
                python_exec = shutil.which("python")
                major, minor = check_python_version(python_exec)
        if major != 3 or minor != 11 or (not python_exec):
            warnings.warn(
                "LeetCode runs tests its solutions on Python 3.11."
                f"We couldn't find a Python 3.11 executable and as such we are using Python {sys.version_info.major}.{sys.version_info.minor}."
            )
            python_exec = sys.executable
        return python_exec

    @classmethod
    def run_file(cls, file: pathlib.Path):
        """
        Parameters
        ----------
        cls
        file: Path
        """
        python_exec = cls.get_executable()
        return cls.execute(
            python_exec,
            str(file.resolve().absolute())
        )


    @classmethod
    def function_location_from_name(cls, function_name: str, boilerplate: str) -> str:
        if "class Solution" in boilerplate:
            return f"Solution().{function_name}"
        return function_name