"""Module containing the Python 3 runner."""

from __future__ import annotations

import shutil
import subprocess
import sys
import typing
import warnings

from typing_extensions import override

from leet import runner

if typing.TYPE_CHECKING:
    import pathlib

PYTHON_MAJOR_VERSION = 3
PYTHON_MINOR_VERSION_LEETCODE = 14

CHECK_VERSION = (
    "import sys; print(sys.version_info.major); print(sys.version_info.minor)"
)


def check_python_version(executable: str | None) -> tuple[int, int]:
    """
    Check the version of the given Python executable.

    Parameters
    ----------
    executable: str | None
        The path to the Python executable.

    Returns
    -------
    tuple[int, int]
        The major and minor version of the Python executable.
    """
    if not executable:
        return (0, 0)
    lines = subprocess.check_output(  # noqa: S603
        [executable, "-c", CHECK_VERSION],
    ).splitlines()
    return (int(lines[0]), int(lines[1]))


class Python3Runner(runner.Runner):
    """A runner for Python 3."""

    HEADER = r'''"""
This file is automatically generated and emulates the Python environment
on the LeetCode platform.
"""
# START OF THE ENVIRONMENT CODE

# Wildcard imports
from string import *
from re import *
from operator import *
from builtins import *
from typing import *
from datetime import *
from collections import *
from heapq import *
from bisect import *
from copy import *
from math import *
from random import *
from statistics import *
from itertools import *
from functools import *
from io import *
from sys import *
from json import *

# Module imports
import datetime
import bisect
import copy
import random
import string
import re
import collections
import heapq
import math
import statistics
import itertools
import functools
import operator
import io
import sys
import json
import os

# Disclaimer: The following modules are not available in this environment.
# `_driver`: This is an internal module which shouldn't be used in any problem.

# ------------------ `precompiled` ------------------
# The `precompiled` module is a module containing LeetCode custom datastructures.
# This is available at runtime on the LeetCode platform.
# It contains the following datastructures:
# - ListNode
# - NestedInteger
# - TreeNode

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class NestedInteger:
    def __init__(self, value=None):
        self.value = value

    def isInteger(self) -> bool:
        return isinstance(self.value, int)

    def getInteger(self) -> int:
        return self.value

    def getList(self) -> List['NestedInteger']:
        return self.value

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Creating a module to store the custom datastructures
import types
precompiled = types.ModuleType(
    'precompiled',
    'A module containing LeetCode custom datastructures.'
)
# Updating the module with the custom datastructures
precompiled.__dict__.update({
    'ListNode': ListNode,
    'NestedInteger': NestedInteger,
    'TreeNode': TreeNode,
})
# Adding it to the list of modules
sys.modules['precompiled'] = precompiled
# The `types` module is not in the default LeetCode Python environment.
del types

# Redefining the different datastructures for them to have the same behavior
# as module elements
ListNode = precompiled.ListNode
NestedInteger = precompiled.NestedInteger
TreeNode = precompiled.TreeNode

# END OF THE ENVIRONMENT CODE
'''

    FOOTER = r'''# START OF THE TESTING CODE

# We could expect that the user decided to remove these imports for whatever reason
from typing import List, Tuple, Dict, Any
# Defining the tests
__LEETCODE_{run_id}_TESTS__: List[Tuple[Dict[str, Any], Any]] = {tests}
#                                       ^^^^^^^^^^^^^^  ^^^
#                                      Input arguments  Expected
#                                                       output
# Example: __LEETCODE_0_TESTS__ = [({{'val1': 1, 'val2': 2}}, 3)]

# We go a little bit fancy here
try:
    from rich.console import Console
    from rich.table import Table
    from rich.progress import track
except Exception:
    # But it shouldn't impact the run
    import traceback
    class Table:
        def __init__(self, title: str, *args, **kwargs):
            self.title = str(title)
            self.columns = []
            self.rows = []

        def add_column(self, title: str, *args, **kwargs):
            self.columns.append(str(title))

        def add_row(self, *args, **kwargs):
            self.rows.append([str(arg) for arg in args])

    class Console:
        def render(self, value: str) -> str:
            return (
                str(value)
                .replace("[red]", "\033[0;31m")
                .replace("[/red]", "\033[0m")
                .replace("[green]", "\033[0;32m")
                .replace("[/green]", "\033[0m")
            )

        def render_table(self, table: Table) -> List[str]:
            max_per_column = [
                max(
                    len(row[index])
                    for row in [table.columns, *table.rows]
                )
                for index, _ in enumerate(table.columns)
            ]
            return [
                self.render(table.title).center(
                    sum(max_per_column) + len(table.columns) * 3
                ),
                "",
                " â”‚ ".join(
                    column.center(max_per_column[index])
                    for index, column in enumerate(table.columns)
                ),
                "â”€â”¼â”€".join(
                    "â”€" * max_per_column[index]
                    for index, _ in enumerate(table.columns)
                ),
                " â”‚ ".join(
                    " â”‚ ".join(
                        row[index].center(max_per_column[index])
                        for index, _ in enumerate(table.columns)
                    )
                    for row in table.rows
                ),
                ""
            ]

        def print(self, *args, **kwargs):
            if isinstance(args[0], Table):
                table = args[0]
                print("\n".join(self.render_table(table)))
            else:
                print(*[self.render(arg) for arg in args], **kwargs)

        def print_exception(self, *args, **kwargs):
            self.print("[red]AN ERROR OCCURED[/red]", *args, **kwargs)
            traceback.print_exc()


    def track(iterable, *args, **kwargs):
        return iterable

console = Console()

def __LEETCODE_{run_id}_RUN_TESTS__():
    """Runs the tests for the solution."""
    try:
        NUMBER_OF_TESTS = str(len(__LEETCODE_{run_id}_TESTS__))
        TEST_MESSAGE_TEMPLATE = f"Test {{{{index}}}}/{{NUMBER_OF_TESTS}}...   "
        INDEX_JUSTIFICATION = len(NUMBER_OF_TESTS)
        MAX_MESSAGE_LENGTH = len(
            TEST_MESSAGE_TEMPLATE.format(index=NUMBER_OF_TESTS)
        )

        for index, (test, expected) in track(
            enumerate(__LEETCODE_{run_id}_TESTS__, start=1),
            description="Running tests",
            transient=True,
            console=console,
            total=len(__LEETCODE_{run_id}_TESTS__),
        ):
            testing_message = TEST_MESSAGE_TEMPLATE.format(
                index=str(index).ljust(INDEX_JUSTIFICATION)
            )
            console.print(testing_message, end="\r")
            # We make sure that the `Solution` class is re-instantiated for each test
            sol = {function_name}(
                **test
            )
            if sol != expected:
                console.print(
                    testing_message
                    + "[red]FAILED[/red] â›‘ï¸".rjust(
                        MAX_MESSAGE_LENGTH - len(testing_message)
                    )
                )
                table = Table(
                    title=f"Test {{index}}/{{NUMBER_OF_TESTS}} â€” [red]Failure[/red]"
                )
                table.add_column("Input")
                table.add_column("Output")
                table.add_column("Expected")
                table.add_row(str(test), str(sol), str(expected))
                console.print(table)
                exit(1)
            else:
                console.print(
                    testing_message
                    + "PASSED âœ…".rjust(MAX_MESSAGE_LENGTH - len(testing_message))
                )
    except Exception as exc:
        console.print_exception()
        raise exc

    console.print("âœ¨ All tests passed! ðŸ™†")

if __name__ == "__main__":
    # Running the solution
    __LEETCODE_{run_id}_RUN_TESTS__()

# END OF THE TESTING CODE
'''
    "This takes `run_id`, `tests` and `function_name` as arguments"

    @classmethod
    @override
    def encode_tests(cls, tests: list[runner.Test]) -> str:
        """
        Encode the tests to be injected into the template.

        Parameters
        ----------
        cls
        tests: list[runner.Test]
            The list of tests to encode.

        Returns
        -------
        str
        """
        return repr([(test.arguments, test.expected) for test in tests]).strip("'")

    @classmethod
    @override
    def get_executable(cls) -> str:
        """
        Return the path to the Python executable.

        It tries to find Python 3.14 as it is the version used by LeetCode.
        If it fails, it falls back to the current Python version.

        Returns
        -------
        str
        """
        major, minor = sys.version_info.major, sys.version_info.minor
        if major == PYTHON_MAJOR_VERSION and minor == PYTHON_MINOR_VERSION_LEETCODE:
            return sys.executable

        for name in [
            f"python{PYTHON_MAJOR_VERSION}.{PYTHON_MINOR_VERSION_LEETCODE}",
            "python3",
            "python",
        ]:
            python_exec = shutil.which(name)
            if python_exec:
                major, minor = check_python_version(python_exec)
                if (
                    major == PYTHON_MAJOR_VERSION
                    and minor == PYTHON_MINOR_VERSION_LEETCODE
                ):
                    return python_exec

        warnings.warn(
            f"LeetCode runs its solutions on Python {PYTHON_MAJOR_VERSION}."
            f"{PYTHON_MINOR_VERSION_LEETCODE}. "
            f"We couldn't find a Python {PYTHON_MAJOR_VERSION}."
            f"{PYTHON_MINOR_VERSION_LEETCODE} executable and as such we are "
            f"using Python {sys.version_info.major}.{sys.version_info.minor}.",
            stacklevel=2,
        )
        return sys.executable

    @classmethod
    @override
    def run_file(cls, file: pathlib.Path) -> tuple[float, float, float]:
        """
        Run the given file with the determined Python executive.

        Parameters
        ----------
        cls
        file: pathlib.Path
            The path to the file to run.
        """
        python_exec = cls.get_executable()
        return cls.execute(
            python_exec,
            str(file.resolve().absolute()),
        )

    @classmethod
    @override
    def function_location_from_name(cls, function_name: str, boilerplate: str) -> str:
        """
        Return the function location based on the boilerplate.

        Parameters
        ----------
        cls
        function_name: str
            The name of the function.
        boilerplate: str
            The boilerplate code.

        Returns
        -------
        str
        """
        if "class Solution" in boilerplate:
            return f"Solution().{function_name}"
        return function_name
