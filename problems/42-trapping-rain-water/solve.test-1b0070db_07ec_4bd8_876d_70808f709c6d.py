"""
This file is automatically generated and emulates the Python environment on the LeetCode platform.
"""
# START OF THE ENVIRONMENT CODE

# Wildcard imports
from string import *
from re import *
from operator import *
from builtins import *
from typing import *
from datetime import *
from collections import *
from heapq import *
from bisect import *
from copy import *
from math import *
from random import *
from statistics import *
from itertools import *
from functools import *
from io import *
from sys import *
from json import *

# Module imports
import datetime
import bisect
import copy
import random
import string
import re
import collections
import heapq
import math
import statistics
import itertools
import functools
import operator
import io
import sys
import json
import os

# Disclaimer: The following modules are not available in this environment.
# `_driver`: This is an internal module which shouldn't be used in any problem.

# ------------------ `precompiled` ------------------
# The `precompiled` module is a module containing LeetCode custom datastructures.
# This is available at runtime on the LeetCode platform.
# It contains the following datastructures:
# - ListNode
# - NestedInteger
# - TreeNode

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class NestedInteger:
    def __init__(self, value=None):
        self.value = value

    def isInteger(self) -> bool:
        return isinstance(self.value, int)

    def getInteger(self) -> int:
        return self.value

    def getList(self) -> List['NestedInteger']:
        return self.value

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Creating a module to store the custom datastructures
import types
precompiled = types.ModuleType('precompiled', 'A module containing LeetCode custom datastructures.')
# Updating the module with the custom datastructures
precompiled.__dict__.update({
    'ListNode': ListNode,
    'NestedInteger': NestedInteger,
    'TreeNode': TreeNode,
})
# Adding it to the list of modules
sys.modules['precompiled'] = precompiled
# The `types` module is not in the default LeetCode Python environment.
del types

# Redefining the different datastructures for them to have the same behavior as module elements
ListNode = precompiled.ListNode
NestedInteger = precompiled.NestedInteger
TreeNode = precompiled.TreeNode

# END OF THE ENVIRONMENT CODE


from time import sleep
class Solution:
    def trap(self, height: List[int]) -> int:
        sleep(2)
        return 6

# START OF THE TESTING CODE

# We could expect that the user decided to remove these imports for whatever reason
from typing import List, Tuple, Dict, Any
# Defining the tests
__LEETCODE_1b0070db_07ec_4bd8_876d_70808f709c6d_TESTS__: List[Tuple[Dict[str, Any], Any]] = [({'height': [4, 2, 0, 3, 2, 5]}, 6), ({'height': [4, 2, 0, 3, 2, 5]}, 6), ({'height': [4, 2, 0, 3, 2, 5]}, 6), ({'height': [4, 2, 0, 3, 2, 5]}, 6), ({'height': [4, 2, 0, 3, 2, 5]}, 6), ({'height': [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]}, 6), ({'height': [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]}, 9), ({'height': [4, 2, 0, 3, 2, 5]}, 9), ({'height': [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]}, 6), ({'height': [4, 2, 0, 3, 2, 5]}, 9)]
#                                       ^^^^^^^^^^^^^^  ^^^
#                                      Input arguments  Expected
#                                                       output
# Example: __LEETCODE_0_TESTS__ = [({'val1': 1, 'val2': 2}, 3)]

# We go a little bit fancy here
try:
    from rich.console import Console
    from rich.table import Table
    from rich.progress import track
except Exception:
    # But it shouldn't impact the run
    import traceback
    class Table:
        def __init__(self, title: str, *args, **kwargs):
            self.title = str(title)
            self.columns = []
            self.rows = []

        def add_column(self, title: str, *args, **kwargs):
            self.columns.append(str(title))

        def add_row(self, *args, **kwargs):
            self.rows.append([str(arg) for arg in args])

    class Console:
        def render(self, value: str) -> str:
            return str(value).replace("[red]", "\033[0;31m").replace("[/red]", "\033[0m").replace("[green]", "\033[0;32m").replace("[/green]", "\033[0m")

        def render_table(self, table: Table) -> List[str]:
            max_per_column = [max(len(row[index]) for row in [table.columns, *table.rows]) for index, _ in enumerate(table.columns)]
            return [
                self.render(table.title).center(sum(max_per_column) + len(table.columns) * 3),
                "",
                " ‚îÇ ".join(
                    column.center(max_per_column[index]) for index, column in enumerate(table.columns)
                ),
                "‚îÄ‚îº‚îÄ".join("‚îÄ" * max_per_column[index] for index, _ in enumerate(table.columns)),
                " ‚îÇ ".join(
                    " ‚îÇ ".join(row[index].center(max_per_column[index]) for index, _ in enumerate(table.columns))
                    for row in table.rows
                ),
                ""
            ]
            
        def print(self, *args, **kwargs):
            if isinstance(args[0], Table):
                table = args[0]
                print("\n".join(self.render_table(table)))
            else:
                print(*[self.render(arg) for arg in args], **kwargs)

        def print_exception(self, *args, **kwargs):
            self.print("[red]AN ERROR OCCURED[/red]", *args, **kwargs)
            traceback.print_exc()

        
    def track(iterable, *args, **kwargs):
        return iterable

console = Console()

def __LEETCODE_1b0070db_07ec_4bd8_876d_70808f709c6d_RUN_TESTS__():
    """Runs the tests for the solution."""
    try:
        NUMBER_OF_TESTS = str(len(__LEETCODE_1b0070db_07ec_4bd8_876d_70808f709c6d_TESTS__))
        TEST_MESSAGE_TEMPLATE = f"Test {{index}}/{NUMBER_OF_TESTS}...   "
        INDEX_JUSTIFICATION = len(NUMBER_OF_TESTS)
        MAX_MESSAGE_LENGTH = len(TEST_MESSAGE_TEMPLATE.format(index=NUMBER_OF_TESTS))

        for index, (test, expected) in track(enumerate(__LEETCODE_1b0070db_07ec_4bd8_876d_70808f709c6d_TESTS__, start=1),
                                            description="Running tests",
                                            transient=True,
                                            console=console,
                                            total=len(__LEETCODE_1b0070db_07ec_4bd8_876d_70808f709c6d_TESTS__)):
            testing_message = TEST_MESSAGE_TEMPLATE.format(index=str(index).ljust(INDEX_JUSTIFICATION))
            console.print(testing_message, end="\r")
            # Here, we make sure that the `Solution` class is re-instantiated for each test
            sol = Solution().trap(
                **test
            )
            if sol != expected:
                console.print(testing_message + "[red]FAILED[/red] ‚õëÔ∏è".rjust(MAX_MESSAGE_LENGTH - len(testing_message)))
                table = Table(title=f"Test {index}/{NUMBER_OF_TESTS} ‚Äî [red]Failure[/red]")
                table.add_column("Input")
                table.add_column("Output")
                table.add_column("Expected")
                table.add_row(str(test), str(sol), str(expected))
                console.print(table)
                exit(1)
            else:
                console.print(testing_message + "PASSED ‚úÖ".rjust(MAX_MESSAGE_LENGTH - len(testing_message)))
    except Exception as exc:
        console.print_exception()
        raise exc
    
    console.print("‚ú® All tests passed! üôÜ")

if __name__ == "__main__":
    # Running the solution
    __LEETCODE_1b0070db_07ec_4bd8_876d_70808f709c6d_RUN_TESTS__()

# END OF THE TESTING CODE

        