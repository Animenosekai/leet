import pathlib
import shutil
import subprocess
import sys
import typing
import dataclasses

import warnings
from leet import runner

CHECK_VERSION = (
    "import sys; print(sys.version_info.major); print(sys.version_info.minor)"
)


def check_python_version(executable: str) -> typing.Tuple[int, int]:
    """
    Parameters
    ----------
    executable: str

    Returns
    -------
    tuple
    """
    lines = subprocess.check_output([executable, "-c", CHECK_VERSION]).splitlines()
    return (int(lines[0]), int(lines[1]))


class Python3Runner(runner.Runner):
    HEADER = r'''\
"""
This file is automatically generated and emulates the Python environment on the LeetCode platform.
"""

# Wildcard imports
from string import *
from re import *
from operator import *
from builtins import *
from typing import *
from datetime import *
from collections import *
from heapq import *
from bisect import *
from copy import *
from math import *
from random import *
from statistics import *
from itertools import *
from functools import *
from io import *
from sys import *
from json import *

# Module imports
import datetime
import bisect
import copy
import random
import string
import re
import collections
import heapq
import math
import statistics
import itertools
import functools
import operator
import io
import sys
import json
import os

# Disclaimer: The `_driver` is missing but this is an internal module which shouldn't be used in any problem.

# Defining the `precompiled` module, which contains some LeetCode custom datastructures.

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class NestedInteger:
    def __init__(self, value=None):
        self.value = value

    def isInteger(self) -> bool:
        return isinstance(self.value, int)

    def getInteger(self) -> int:
        return self.value

    def getList(self) -> List['NestedInteger']:
        return self.value

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# Creating a module to store the custom datastructures
import types
precompiled = types.ModuleType('precompiled', 'A module containing LeetCode custom datastructures.')
# Updating the module with the custom datastructures
precompiled.__dict__.update({
    'ListNode': ListNode,
    'NestedInteger': NestedInteger,
    'TreeNode': TreeNode,
})
# Adding it to the list of modules
sys.modules['precompiled'] = precompiled
# The `types` module is not in the default LeetCode Python environment.
del types

# Redefining the different datastructures for them to have the same behavior as module elements
ListNode = precompiled.ListNode
NestedInteger = precompiled.NestedInteger
TreeNode = precompiled.TreeNode
'''

    FOOTER = r'''\
# We could expect that the user decided to remove these imports for whatever reason
from typing import List, Tuple, Dict, Any
# Defining the tests
__LEETCODE_{run_id}_TESTS__: List[Tuple[Dict[str, Any], Any]] = {tests}
#                                       ^^^^^^^^^^^^^^  ^^^
#                                      Input arguments  Expected
#                                                       output
# Example: __LEETCODE_0_TESTS__ = [({{'val1': 1, 'val2': 2}}, 3)]

def __LEETCODE_{run_id}_RUN_TESTS__():
    """Runs the tests for the solution."""
    NUMBER_OF_TESTS = str(len(__LEETCODE_{run_id}_TESTS__))
    TEST_MESSAGE_TEMPLATE = f"Test {{{{index}}}}/{{NUMBER_OF_TESTS}}... "
    INDEX_JUSTIFICATION = len(NUMBER_OF_TESTS)
    MAX_MESSAGE_LENGTH = len(TEST_MESSAGE_TEMPLATE.format(index=NUMBER_OF_TESTS))
    for index, (test, expected) in enumerate(__LEETCODE_{run_id}_TESTS__, start=1):
        testing_message = TEST_MESSAGE_TEMPLATE.format(index=str(index).ljust(INDEX_JUSTIFICATION))
        print(testing_message, end="\r")
        sol = {function_name}(
            **test
        )
        if sol != expected:
            print(testing_message + "FAILED â›‘ï¸".rjust(MAX_MESSAGE_LENGTH - len(testing_message)))
            print("Given input", test)
            print("Got", sol)
            print("Expected", expected)
            exit(1)
        else:
            print(testing_message + "PASSED âœ…".rjust(MAX_MESSAGE_LENGTH - len(testing_message)))
    print("âœ¨ All tests passed! ðŸ™†")

if __name__ == "__main__":
    # Running the solution
    __LEETCODE_{run_id}_RUN_TESTS__()
'''
    "This takes `run_id`, `tests` and `function_name` as arguments"

    @classmethod
    def encode_tests(cls, tests: typing.List[runner.Test]) -> str:
        """
        Parameters
        ----------
        cls
        tests: list

        Returns
        -------
        str
        """
        return repr([
            (test.arguments, test.expected) for test in tests
        ]).strip("'")

    @classmethod
    def get_executable(cls) -> str:
        major, minor = (sys.version_info.major, sys.version_info.minor)
        if major != 3 or minor != 11:
            python_exec = shutil.which("python3.11")
            major, minor = check_python_version(python_exec)
            if major != 3 or minor != 11:
                python_exec = shutil.which("python3")
                major, minor = check_python_version(python_exec)
            if major != 3 or minor != 11:
                python_exec = shutil.which("python")
                major, minor = check_python_version(python_exec)
        if major != 3 or minor != 11 or (not python_exec):
            warnings.warn(
                "LeetCode runs tests its solutions on Python 3.11."
                f"We couldn't find a Python 3.11 executable and as such we are using Python {sys.version_info.major}.{sys.version_info.minor}."
            )
            python_exec = sys.executable
        return python_exec

    @classmethod
    def run_file(cls, file: pathlib.Path):
        """
        Parameters
        ----------
        cls
        file: Path
        """
        python_exec = cls.get_executable()
        return cls.execute(
            python_exec,
            str(file.resolve().absolute())
        )

